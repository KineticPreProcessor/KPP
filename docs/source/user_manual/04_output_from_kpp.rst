.. _output-from-kpp:

###############
Output from KPP
###############

==================
The Fortran90 Code
==================

.. figure: kpp2_use_diaggram

.. image:: kpp2_use_diagr.pdf

   Figure caption

.. container:: table*

   .. container:: center

      ========== ==================================================== ====
      Subroutine Description                                          File
      \          ODE function                                         root
      \          ODE Jacobian in sparse format                        root
      \          sparse multiplication                                root
      \          sparse multiplication                                root
      \          ODE Jacobian in full format                          root
      \          ODE Hessian in sparse format                         root
      \          Hessian action on vectors                            root
      \          Transposed Hessian action on vectors                 root
      \          Derivatives of Fun with respect to rate coefficients root
      \          Derivatives of Jac with respect to rate coefficients root
      \          Reactant products                                    root
      \          Jacobian of reactant products                        root
      \          Sparse LU decomposition                              root
      \          Sparse back substitution                             root
      \          Update photolysis rate coefficients                  root
      \          Update all rate coefficients                         root
      \          Update solar intensity                               root
      \          Set initial values                                   root
      \          Integrate one time step                              root
      \          Check mass balance for selected atoms                root
      \          Shuffle concentration vector                         root
      \          Shuffle concentration vector                         root
      \          Utility for command                                  root
      \          Utility for command                                  root
      \          Utility for command                                  root
      \          Calculate reaction number from equation tag          root
      \                                                               
      ========== ==================================================== ====

The code generated by KPP is organized in a set of separate files. Each
has a time stamp and a complete description of how it was generated at
the begining of the file. The files associated with root are named with
a corresponding prefix “root”. The list of files and a short description
is shown in Table `[tab:generated_files] <#tab:generated_files>`__. All
subroutines and functions, global parameters, variables, and sparsity
data structures are encapsulated in modules. There is exactly one module
in each file, and the name of the module is identical to the file name
but without the suffix . Fig. `[fig:use_diagr] <#fig:use_diagr>`__ shows
how these modules are related to each other. A concise list of the main
subroutines generated by KPP is shown in
Table `[tab:functions] <#tab:functions>`__. The generated code is
consistent with the Fortran90 standard. It will not exceed the maximum
number of 39 continuation lines. If KPP cannot properly split an
expression to keep the number of continuation lines below the threshold
then it will generate a warning message pointing to the location of this
expression.

.. important:: The default Fortran90 file suffix is :code:`.f90`.  This can be
   changed to :code:`F90` by setting :code:`#UPPERCASEF90 on` in the KPP
   definition file. 

.. _Main:

root_Main.f90 (or .F90)
-----------------------

:file:`root_Main.f90` (or :file:`root_Main.F90`) root is the main
Fortran90 program. It contains the driver after modifications by the
substitution preprocessor. The name of the file is computed by KPP by
appending the suffix to the root name. 

.. _Model:

root_Model.f90 (or .F90)
------------------------

The file :file:`root_Model.f90` (or :file:`root_Model.F90`) completely
defines the model by using all the associated modules. 

.. _Initialize:

root_Initialize.f90 (or .F90)
-----------------------------

The file :file:`root_Initialize.f90` (or :file:`root_Initialize.F9O`)
contains the subroutine which defines initial values of the chemical
species. The driver calls the subroutine once before the time
integration loop starts. 

.. _Integrator:

root_Integrator.f90 (or .F90)
-----------------------------

The file :file:`root_Integrator.f90` (or :file:`root_Integrator.F90`)
contains the subroutine which is called every time step during the
integration. The integrator that was chosen with :code:`#INTEGRATOR`
is also included in this file.  In case of an unsuccessful
integration, the module root provides a short error message 
in the public variable :code:`IERR_NAME`.

.. _Monitor:

root_Monitor.f90 (or .F90)
--------------------------

The file :file:`root_Monitor.f90` (:file:`root_Monitor.F90`) contains
arrays with information about the chemical mechanism. The names of all
species are included in :code:`SPC_NAMES` and the names of all
equations are included in :code:`EQN_NAMES`. 

It was shown in :ref:`eqntags` that each reaction
in the section may start with an equation tag which is enclosed in
angle brackets, e.g.:  

.. code-block:: console

   <J1> NO2 + hv = NO + O : 0.533*SUN;

If the equation tags are switched on, KPP also generates the array . In
combination with and the function that converts the equation tag to the
KPP-internal equation number, this can be used to describe a reaction:

.. code-block:: console

     PRINT *,'Reaction J1 is:', &
       EQN_NAMES(tag2num('J1'))

.. _Precision:

root_Precision.f90 (or .F90)
----------------------------

Fortran90 code uses parameterized real types. root contains the
following real kind definitions:

.. code-block:: Fortran90

   ! KPP_SP - Single precision kind
     INTEGER, PARAMETER :: &
       SP = SELECTED_REAL_KIND(6,30)
   ! KPP_DP - Double precision kind
     INTEGER, PARAMETER :: &
       DP = SELECTED_REAL_KIND(12,300)

Depending on the choice of the command, the real variables are of type
double () or single precision (). Changing the parameters of the
function in this module will cause a change in the working precision for
the whole model.

.. _Rates:

root_Rates.f90 (or .F90)
------------------------

The code to update the rate constants is in root. The user defined rate
law functions are also placed here.

.. _`sec:output-parameters`:

root\ ``_Parameters.f90``
~~~~~~~~~~~~~~~~~~~~~~~~~

The global parameters (Table `3 <#tab:parameters>`__) are defined and
initialized in root.

KPP orders the variable species such that the sparsity pattern of the
Jacobian is maintained after an LU decomposition. For our example there
are five variable species (=5) ordered as

.. code-block:: Fortran90

   ind_O1D=1, ind_O=2, ind_O3=3,
   ind_NO=4, ind_NO2=5

and two fixed species (=2)

.. code-block:: Fortran90

   ind_M = 6, ind_O2 = 7.

KPP defines a complete set of simulation parameters, including the
numbers of variable and fixed species, the number of chemical reactions,
the number of nonzero entries in the sparse Jacobian and in the sparse
Hessian, etc. Some important simulation parameters generated by KPP are
presented in Table `3 <#tab:parameters>`__.

.. container::
   :name: tab:parameters

   .. table:: List of important simulation parameters and their values
   for the ``small_strato`` example

      ========= ================================ =====
      Parameter Represents                       Value
      \         No. chemical species             7
      \         No. variable species             5
      \         No. fixed species                2
      \         No. reactions                    10
      \         No. nonzero entries Jacobian     18
      \         As above, after LU factorization 19
      \         Length, sparse Hessian           10
      \         Length, sparse Jacobian          13
      \         Length, stoichiometric matrix    22
      \         Index of species *spc* in        
      \         Index of fixed species *spc* in  
      \                                          
      ========= ================================ =====

.. _`sec:output-global`:

root\ ``_Global.f90``
~~~~~~~~~~~~~~~~~~~~~

The global variables (Table `4 <#tab:global>`__) are declared in root.
Global variables are presented in Table `4 <#tab:global>`__.

.. container::
   :name: tab:global

   .. table:: List of important global variables

      =============== ================================
      Global variable Represents
      \               Concentrations, all species
      \               Concentrations, variable species
      \               Concentrations, fixed species
      \               Rate coefficient values
      \               Current integration time
      \               Sun intensity between 0 and 1
      \               Temperature
      \               Simulation start/end time
      \               Simulation step
      \               Absolute tolerances
      \               Relative tolerances
      \               Lower bound for time step
      \               Upper bound for time step
      \               Conversion factor
      \               Names of chemical species
      \               Names of chemical equations
      \               
      =============== ================================

Both variable and fixed species are stored in the one-dimensional array
. The first part (indices from 1 to ) contains the variable species, and
the second part (indices from to ) the fixed species. The total number
of species is the sum of the and . The parts can also be accessed
separately through the arrays and :

::

   VAR(1:NVAR) => C(1:NVAR)
   FIX(1:NFIX) => C(NVAR+1:NSPEC)

.. _`sec:output-ode-fun`:

root\ ``_Function.f90``
~~~~~~~~~~~~~~~~~~~~~~~

The chemical ODE system for our example is:

.. math::

   \begin{aligned}
     \frac{{\mathrm{d}}\, [O(^1D)]}}{{\mathrm{d}}t} & = & k_{5}\, [O_3] - k_{6}\,
     [O(^1D)]\, [M] - k_{7}\, [O(^1D}]\, [O_3]\\
     \frac{{\mathrm{d}}\, [O]}{{\mathrm{d}}t} & = & 2\, k_{1}\, [O_2] - k_{2}\,
     [O]\, [O_2] + k_{3}\, [O_3]\\
     & & - k_{4}\, [O]\, [O_3]+ k_{6}\, [O(^1D)]\,
     [{M}]\\
     & & - k_{9}\, [O]\, [NO_2] + k_{10}\, [NO_2]\\
     \frac{{\mathrm{d}}\, [{O_3}]}{{\mathrm{d}}t} & = & k_{2}\, [O]\, [O_2] -
     k_{3}\, [O_3] - k_{4}\, [O]\, [O_3] - k_{5}\,
     [{O_3}]\\
     & & - k_{7}\, [O(^1D)]\, [{O_3}] - k_{8}\, [{O_3}]\, 
     [{NO}]\\
     \frac{{\mathrm{d}}\, [NO]}}{{\mathrm{d}}t} & = & - k_{8}\, [O_3]\, [NO] +
     k_{9}\, [O]\, [NO_2] + k_{10}\, [NO_2]\\
     \frac{{\mathrm{d}}\, [NO_2]}{{\mathrm{d}}t} & = & k_{8}\, [O_3]\, [NO] -
     k_{9}\, [O]\, [NO_2] - k_{10}\, [NO_2]
   \end{aligned}

where square brackets denote concentrations of the species. The code for
the ODE function is in root. The chemical reaction mechanism represents
a set of ordinary differential equations (ODEs) of dimension . The
concentrations of fixed species are parameters in the derivative
function. The subroutine computes first the vector of reaction rates and
then the vector of variable species time derivatives. The input
arguments , , and are the concentrations of variable species, fixed
species, and the rate coefficients, respectively. Below is the Fortran90
code generated by KPP for the ODE function of our example.

.. code-block:: Fortran90

   SUBROUTINE Fun (V, F, RCT, Vdot )
      REAL(kind=DP) ::  V(NVAR), &
            F(NFIX), RCT(NREACT), &
            Vdot(NVAR), A(NREACT) &
   ! Computation of equation rates
      A(1) = RCT(1)*F(2)
      A(2) = RCT(2)*V(2)*F(2)
      A(3) = RCT(3)*V(3)
      A(4) = RCT(4)*V(2)*V(3)
      A(5) = RCT(5)*V(3)
      A(6) = RCT(6)*V(1)*F(1)
      A(7) = RCT(7)*V(1)*V(3)
      A(8) = RCT(8)*V(3)*V(4)
      A(9) = RCT(9)*V(2)*V(5)
      A(10) = RCT(10)*V(5)
   ! Aggregate function
      Vdot(1) = A(5)-A(6)-A(7)
      Vdot(2) = 2*A(1)-A(2)+A(3) &
                -A(4)+A(6)-A(9)+A(10)
      Vdot(3) = A(2)-A(3)-A(4)-A(5) &
                -A(7)-A(8)
      Vdot(4) = -A(8)+A(9)+A(10)
      Vdot(5) = A(8)-A(9)-A(10)
   END SUBROUTINE Fun

.. _`Jacobian-and-JacobianSP:

root_Jacobian.f90 and root_JacobianSP.f90 (or .F90)
----------------------------------------------------

.. figure:: Figures/small_jac.pdf
   :alt: The sparsity pattern of the Jacobian for the ``small_strato``
   example. All non-zero elements are marked with a bullet. Note that
   even though ``J(3,5)=0``, it is also included here because of the
   fill-in. **((TODO: ADRIAN, IS THIS EXPLANATION OF J(3,5) CORRECT?))**
   :name: fig:jac

   The sparsity pattern of the Jacobian for the ``small_strato``
   example. All non-zero elements are marked with a bullet. Note that
   even though ``J(3,5)=0``, it is also included here because of the
   fill-in. **((TODO: ADRIAN, IS THIS EXPLANATION OF J(3,5) CORRECT?))**

The Jacobian matrix for our example contains 18 non-zero elements:

.. math::

   \begin{aligned}
     \mathbf{J}(1,1) & = & - k_{6}\, [{M}] - k_{7}\, [{O_3}]\\
     \mathbf{J}(1,3) & = & k_{5} - k_{7}\, [{O(^1D)}]\\
     \mathbf{J}(2,1) & = & k_{6}\, [{M}]\\
     \mathbf{J}(2,2) & = & - k_{2}\, [{O_2}] - k_{4}\, [{O_3}] 
                           - k_{9}\, [{NO_2}]\\
     \mathbf{J}(2,3) & = & k_{3} - k_{4}\, [{O}]\\
     \mathbf{J}(2,5) & = & - k_{9}\, [{O}] + k_{10}\\
     \mathbf{J}(3,1) & = & - k_{7}\, [{O_3}]\\
     \mathbf{J}(3,2) & = & k_{2}\, [{O_2}] - k_{4}\, [{O_3}]\\
     \mathbf{J}(3,3) & = & - k_{3} - k_{4}\, [{O}] - k_{5} - k_{7}\, 
                           [{O(^1D)}] - k_{8}\, [{NO}]\\
     \mathbf{J}(3,4) & = & - k_{8}\, [{O_3}]\\
     \mathbf{J}(4,2) & = & k_{9}\, [{NO_2}]\\
     \mathbf{J}(4,3) & = & - k_{8}\, [{NO}]\\
     \mathbf{J}(4,4) & = & - k_{8}\, [{O_3}]\\
     \mathbf{J}(4,5) & = & k_{9}\, [{O}] + k_{10}\\
     \mathbf{J}(5,2) & = & - k_{9}\, [{NO_2}]\\
     \mathbf{J}(5,3) & = & k_{8}\, [{NO}]\\
     \mathbf{J}(5,4) & = & k_{8}\, [{O_3}]\\
     \mathbf{J}(5,5) & = & - k_{9}\, [{O}] - k_{10}\\
   \end{aligned}

It defines how the temporal change of each chemical species depends on
all other species. For example, :math:`\mathbf{J}(5,2)` shows that
(species number 5) is affected by (species number 2) via reaction number
R9. The sparse data structures for the Jacobian are declared and
initialized in root. The code for the ODE Jacobian and sparse
multiplications is in root. The Jacobian of the ODE function is
automatically constructed by KPP. KPP generates the Jacobian subroutine
or where the latter is generated when the sparse format is required.
Using the variable species , the fixed species , and the rate
coefficients as input, the subroutine calculates the Jacobian . The
default data structures for the sparse compressed on rows Jacobian
representation are shown in Table `5 <#tab:sparse-jac>`__ (for the case
where the LU fill-in is accounted for). stores the elements of the
Jacobian in row order. Each row starts at position , and . The location
of the -th diagonal element is . The sparse element is the Jacobian
entry in row and column . For the example KPP generates the following
Jacobian sparse data structure:

.. code-block:: Fortran90

   LU_ICOL = (/ 1,3,1,2,3,5,1,2,3,4, &
               5,2,3,4,5,2,3,4,5 /)
   LU_IROW = (/ 1,1,2,2,2,2,3,3,3,3, &
               3,4,4,4,4,5,5,5,5 /)
   LU_CROW = (/ 1,3,7,12,16,20 /)
   LU_DIAG = (/ 1,4,9,14,19,20 /)

This is visualized in Fig. `1 <#fig:jac>`__. The sparsity coordinate
vectors are computed by KPP and initialized statically. These vectors
are constant as the sparsity pattern of the Jacobian does not change
during the computation.

.. container::
   :name: tab:sparse-jac

   .. table:: Sparse Jacobian Data Structures

      =============== =========================
      Global variable Represents
      \               Jacobian nonzero elements
      \               Row indices
      \               Column indices
      \               Start of rows
      \               Diagonal entries
      \               
      =============== =========================

Two other KPP-generated routines, and are useful for direct and adjoint
sensitivity analysis. They perform sparse multiplication of (or its
transpose for ) with the user-supplied vector without any indirect
addressing.

.. _`sec:output-ode-hess`:

root\ ``_Hessian.f90`` and root\ ``_HessianSP.f90``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. container:: figure*

   .. image:: Figures/small_hess1.pdf
      :alt: image
      :width: 80.0%

The sparse data structures for the Hessian are declared and initialized
in root. The Hessian function and associated sparse multiplications are
in root. The Hessian contains the second order derivatives of the time
derivative functions. More exactly, the Hessian is a 3-tensor such that

.. math::

   H_{i,j,k} = \frac{\partial^2 ({\mathrm{d}}c/{\mathrm{d}}t)_i}{\partial c_j \,\partial c_k}~,
     \qquad 1 \le i,j,k \le N_{\rm var}~.
   \label{eqn:Hessian1}

KPP generates the routine . Using the variable species , the fixed
species , and the rate coefficients as input, the subroutine calculates
the Hessian. The Hessian is a very sparse tensor. The sparsity of the
Hessian for our example is visualized in
Fig. `[fig:hess1] <#fig:hess1>`__. KPP computes the number of nonzero
Hessian entries and saves it in the variable . The Hessian itself is
represented in coordinate sparse format. The real vector holds the
values, and the integer vectors , , and hold the indices of nonzero
entries as illustrated in Table `6 <#tab:sparse-hess>`__. Since the time
derivative function is smooth, these Hessian matrices are symmetric,
:math:`_{i,j,k}`\ =\ :math:`_{i,k,j}`. KPP stores only those entries
:math:`_{i,j,k}` with :math:`j \le k`. The sparsity coordinate vectors ,
, and are computed by KPP and initialized statically. They are constant
as the sparsity pattern of the Hessian does not change during the
computation.

.. container::
   :name: tab:sparse-hess

   .. table:: Sparse Hessian Data

      ======== ===========================================
      Variable Represents
      \        Hessian nonzero elements :math:`_{i,j,k}`
      \        Index :math:`i` of element :math:`_{i,j,k}`
      \        Index :math:`j` of element :math:`_{i,j,k}`
      \        Index :math:`k` of element :math:`_{i,j,k}`
      \        
      ======== ===========================================

The routines and compute the action of the Hessian (or its transpose) on
a pair of user-supplied vectors and . Sparse operations are employed to
produce the result vector.

.. _`sec:output-la`:

root\ ``_LinearAlgebra.f90``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sparse linear algebra routines are in the file root. To numerically
solve for the chemical concentrations one must employ an implicit
timestepping technique, as the system is usually stiff. Implicit
integrators solve systems of the form

.. math:: P\, x = (I - h \gamma J)\, x = b

where the matrix :math:`P=I - h \gamma J` is refered to as the
“prediction matrix”. :math:`I` the identity matrix, :math:`h` the
integration time step, :math:`\gamma` a scalar parameter depending on
the method, and :math:`J` the system Jacobian. The vector :math:`b` is
the system right hand side and the solution :math:`x` typically
represents an increment to update the solution.

The chemical Jacobians are typically sparse, i.e. only a relatively
small number of entries are nonzero. The sparsity structure of :math:`P`
is given by the sparsity structure of the Jacobian, and is produced by
KPP (with account for the fill-in) as discussed above.

KPP generates the sparse linear algebra subroutine which performs an
in-place, non-pivoting, sparse LU decomposition of the prediction matrix
:math:`P`. Since the sparsity structure accounts for fill-in, all
elements of the full LU decomposition are actually stored. The output
argument returns a value that is nonzero if singularity is detected.

The subroutines and use the in-place LU factorization :math:`P` as
computed by and perform sparse backward and forward substitutions (using
:math:`P` or its transpose). The sparse linear algebra routines and are
extremely efficient, as shown by :raw-latex:`\citep{IMPLEMENTATION}`.

.. _Stoichiom-and_StoichiomSP:

root_Stoichiom.f90 and root_StoichiomSP.f90 (or .F90)
-----------------------------------------------------

These files contain a description of the chemical mechanism in
stoichiometric form. The file root contains the functions for reactant
products and its Jacobian, and derivatives with respect to rate
coefficients. The declaration and initialization of the stoichiometric
matrix and the associated sparse data structures is done in root.

The stoichiometric matrix is constant sparse. For our example the matrix
has 22 nonzero entries out of 50 entries. KPP produces the
stoichiometric matrix in sparse, column-compressed format, as shown in
Table `7 <#tab:sparse-stoicm>`__. Elements are stored in columnwise
order in the one-dimensional vector of values . Their row and column
indices are stored in and respectively. The vector contains pointers to
the start of each column. For example column starts in the sparse vector
at position and ends at . The last value simplifies the handling of
sparse data structures.

.. container::
   :name: tab:sparse-stoicm

   .. table:: Sparse Stoichiometric Matrix

      =============== =====================
      Global variable Represents
      \               Stoichiometric matrix
      \               Row indices
      \               Column indices
      \               Start of columns
      \               
      =============== =====================

The subroutine computes the reactant products for each reaction, and the
subroutine computes the Jacobian of reactant products vector, i.e.:

.. math:: {\tt JVRP} = \partial {\tt ARP} / \partial {\tt V}

The matrix is sparse and is computed and stored in row compressed sparse
format, as shown in Table `8 <#tab:sparse-jvrp>`__. The parameter holds
the number of nonzero elements. For our example:

::

   NJVRP = 13
   CROW_JVRP = (/ 1,1,2,3,5,6,7,9,11,13,14 /)
   ICOL_JVRP = (/ 2,3,2,3,3,1,1,3,3,4,2,5,4 /)

.. container::
   :name: tab:sparse-jvrp

   .. table:: Sparse Data for Jacobian of Reactant Products

      =============== ========================
      Global variable Represents
      \               Nonzero elements of JVRP
      \               Column indices in JVRP
      \               Row indices in JVRP
      \               Start of rows in JVRP
      \               
      =============== ========================

If is set to , the stoichiometric formulation allows a direct
computation of the derivatives with respect to rate coefficients.

The subroutine computes the partial derivative of the ODE function with
respect to a subset of reaction coefficients, whose indices are
specifies in the array

.. math:: {\tt DFDR} = \partial {\tt Vdot} / \partial {\tt RCT(JCOEFF)}

Similarly one can obtain the partial derivative of the Jacobian with
respect to a subset of the rate coefficients. More exactly, KPP
generates the subroutine which calculates , the product of this partial
derivative with a user-supplied vector:

.. math:: {\tt DJDR} = [ \partial {\tt JVS} / \partial {\tt RCT(JCOEFF)} ] \times {\tt U}

.. _Stochastic:

root_Stochastic.f90 (or .F90)
-----------------------------

If the generation of stochastic functions is switched on, KPP produces
the file root with the following functions:

calculates the propensity vector. The propensity function uses the
number of molecules of variable () and fixed () species, as well as the
stochastic rate coefficients () to calculate the vector of propensity
rates (). The propensity :math:`_j` defines the probability that the
next reaction in the system is the :math:`j^{th}` reaction.

converts deterministic rates to stochastic. The stochastic rate
coefficients () are obtained through a scaling of the deterministic rate
coefficients (). The scaling depends on the of the reaction container
and on the number of molecules which react.

calculates changes in the number of molecules. When the reaction with
index takes place, the number of molecules of species involved in that
reaction changes. The total number of molecules is updated by the
function.

These functions are used by the Gillespie numerical integrators (direct
stochastic simulation algorithm). These integrators are provided in both
Fortran90 and C implementations (the template file name is ). Drivers
for stochastic simulations are also implemented (the template file name
is ).

.. _`sec:output-utility`:

root_Util.f90 (or .F90)
-----------------------

The utility and input/output functions are in root. In addition to the
chemical system description routines discussed above, KPP generates
several utility routines, some of which are summarized in
Table `[tab:functions] <#tab:functions>`__.

The subroutines , , and can be used to print the concentration of the
species that were selected with to the file root.

.. _`sec:output-mexcode`:

root_mex_Fun.f90, root_mex_Jac_SP.f90, and root_mex_Hessian.f90 (or .F90)
-------------------------------------------------------------------------

Mex is a *M*\ atlab *ex*\ tension. KPP generates the mex routines for
the ODE function, Jacobian, and Hessian, for the target languages C,
Fortran77, and Fortran90. After compilation (using Matlab’s mex
compiler) the mex functions can be called instead of the corresponding
Matlab m-functions. Since the calling syntaxes are identical, the user
only has to insert the string within the corresponding function name.
Replacing m-functions by mex-functions gives the same numerical results,
but the computational time could be considerably smaller, especially for
large kinetic systems.

If possible we recommend to build mex files using the C language, as
Matlab offers most mex interface options for the C language. Moreover,
Matlab distributions come with a native C compiler (lcc) for building
executable functions from mex files. Fortran77 mex files work well on
most platforms without additional efforts. However, the mex files built
using Fortran90 may require further platform-specific tuning of the mex
compiler options.

.. _Makefile:

============
The Makefile
============


KPP produces a Makefile that allows for an easy compilation of all
KPP-generated source files. The file name is . The Makefile assumes that
the selected driver contains the main program. However, if no driver was
selected (i.e. ), it is necessary to add the name of the main program
file manually to the Makefile.

.. _`sec:c`:

==========
The C Code
==========

The driver file root contains the main (driver) and numerical integrator
functions, as well as declarations and initializations of global
variables. The generated C code includes three header files which are -d
in other files as appropriate. The global parameters
(Table `3 <#tab:parameters>`__) are -d in the header file root. The
global variables (Table `4 <#tab:global>`__) are extern-declared in
root, and declared in the driver file root. The header file root
contains extern declarations of sparse data structures for the Jacobian
(Table `5 <#tab:sparse-jac>`__), Hessian
(Table `6 <#tab:sparse-hess>`__), stoichiometric matrix
(Table `7 <#tab:sparse-stoicm>`__), and the Jacobian of reaction
products (Table `8 <#tab:sparse-jvrp>`__). The actual declarations of
each data structures is done in the corresponding files.

The code for the ODE function (Sect. `4.1.10 <#sec:output-ode-fun>`__)
is in root. The code for the ODE Jacobian and sparse multiplications
(Sect. `4.1.11 <#sec:output-ode-jac>`__) is in root, and the declaration
and initialization of the Jacobian sparse data structures
(Table `5 <#tab:sparse-jac>`__) is in the file root. Similarly, the
Hessian function and associated sparse multiplications
(Section `4.1.12 <#sec:output-ode-hess>`__) are in root, and the
declaration and initialization of Hessian sparse data structures (Table
`6 <#tab:sparse-hess>`__) in root.

The file root contains the functions for reactant products and its
Jacobian, and derivatives with respect to rate coefficients
(Sect. `4.1.14 <#sec:output-stoichiom>`__). The declaration and
initialization of the stoichiometric matrix and the associated sparse
data structures (Tables `7 <#tab:sparse-stoicm>`__ and
`8 <#tab:sparse-jvrp>`__) is done in root.

Sparse linear algebra routines (Sect. `4.1.13 <#sec:output-la>`__) are
in the file root. The code to update the rate constants and user defined
code for rate laws is in root.

Various utility and input/output functions
(Sect. `4.1.16 <#sec:output-utility>`__) are in root and root.

Finally, mex gateway routines that allow the C implementation of the ODE
function, Jacobian, and Hessian to be called directly from Matlab
(Sect. `4.1.17 <#sec:output-mexcode>`__) are also generated (in the
files root, root, and root).

.. _`sec:f77`:

==================
The Fortran77 Code
==================

The general layout of the Fortran77 code is similar to the layout of the
C code. The driver file root contains the main (driver) and numerical
integrator functions.

The generated Fortran77 code includes three header files. The global
parameters (Table `3 <#tab:parameters>`__) are defined as parameters and
initialized in the header file root. The global variables
(Table `4 <#tab:global>`__) are declared in root as common block
variables. There are global common blocks for real (), integer (), and
character () global data. They can be accessed from within each program
unit that includes the global header file.

The header file root contains common block declarations of sparse data
structures for the Jacobian (Table `5 <#tab:sparse-jac>`__), Hessian
(Table `6 <#tab:sparse-hess>`__), stoichiometric matrix
(Table `7 <#tab:sparse-stoicm>`__), and the Jacobian of reaction
products (Table `8 <#tab:sparse-jvrp>`__). These sparse data structures
are initialized in four named block data statements: (in root), (in
root), and (in root).

The code for the ODE function (Sect. `4.1.10 <#sec:output-ode-fun>`__)
is in root. The code for the ODE Jacobian and sparse multiplications
(Sect. `4.1.11 <#sec:output-ode-jac>`__) is in root. The Hessian
function and associated sparse multiplications
(Sect. `4.1.12 <#sec:output-ode-hess>`__) are in root.

The file root contains the functions for reactant products and its
Jacobian, and derivatives with respect to rate coefficients
(Sect. `4.1.14 <#sec:output-stoichiom>`__). The declaration and
initialization of the stoichiometric matrix and the associated sparse
data structures (Tables `7 <#tab:sparse-stoicm>`__ and
`8 <#tab:sparse-jvrp>`__) is done in the block data statement.

Sparse linear algebra routines (Sect. `4.1.13 <#sec:output-la>`__) are
in the file root. The code to update the rate constants is in root, and
the utility and input/output functions
(Sect. `4.1.16 <#sec:output-utility>`__) are in root and root.

Matlab-mex gateway routines for the ODE function, Jacobian, and Hessian
are discussed in Sect. `4.1.17 <#sec:output-mexcode>`__.

.. _`sec:matlab`:

===============
The Matlab Code
===============

Matlab (http://www.mathworks.com/products/matlab/) provides a high-level
programming environment that allows algorithm development, numerical
computations, and data analysis and visualization. The KPP-generated
Matlab code allows for a rapid prototyping of chemical kinetic schemes,
and for a convenient analysis and visualization of the results.
Differences between different kinetic mechanisms can be easily
understood. The Matlab code can be used to derive reference numerical
solutions, which are then compared against the results obtained with
user-supplied numerical techniques. Last but not least Matlab is an
excellent environment for educational purposes. KPP/Matlab can be used
to teach students fundamentals of chemical kinetics and chemical
numerical simulations.

Each Matlab function has to reside in a separate m-file. Function calls
use the m-function-file names to reference the function. Consequently,
KPP generates one m-function-file for each of the functions discussed in
Sections `4.1.10 <#sec:output-ode-fun>`__,
`4.1.11 <#sec:output-ode-jac>`__, `4.1.12 <#sec:output-ode-hess>`__,
`4.1.13 <#sec:output-la>`__, `4.1.14 <#sec:output-stoichiom>`__, and
`4.1.16 <#sec:output-utility>`__. The names of the m-function-files are
the same as the names of the functions (prefixed by the model name
root).

The Matlab syntax for calling each function is

.. code-block:: console

   [Vdot] = Fun    (V, F, RCT);
   [JVS ] = Jac_SP (V, F, RCT);
   [HESS] = Hessian(V, F, RCT);

The global parameters (Table `3 <#tab:parameters>`__) are defined as
Matlab variables and initialized in the file root. The variables of
Table `4 <#tab:global>`__ are declared as Matlab variables in the file
root. They can be accessed from within each Matlab function by using
declarations of the variables of interest.

The sparse data structures for the Jacobian
(Table `5 <#tab:sparse-jac>`__), the Hessian
(Table `6 <#tab:sparse-hess>`__), the stoichiometric matrix
(Table `7 <#tab:sparse-stoicm>`__), and the Jacobian of reaction
products (Table `8 <#tab:sparse-jvrp>`__) are declared as Matlab
variables in the file root. They are initialized in separate m-files,
namely root root, and root respectively.

Two wrappers (root and root) are provided for interfacing the ODE
function and the sparse ODE Jacobian with Matlab’s suite of ODE
integrators. Specifically, the syntax of the wrapper calls matches the
syntax required by Matlab’s integrators like ode15s. Moreover, the
Jacobian wrapper converts the sparse KPP format into a Matlab sparse
matrix.

.. container:: table*

   .. container:: center

      ==== ============================================================
      File Description
      root driver
      root Global parameters
      root Global variables
      root Global monitor variables
      root Global sparsity data
      root Template for ODE function
      root ODE function
      root Template for ODE Jacobian
      root ODE Jacobian in sparse format
      root Sparsity data structures
      root ODE Hessian in sparse format
      root Sparsity data structures
      root Hessian action on vectors
      root Transposed Hessian action on vectors
      root Derivatives of Fun and Jac with respect to rate coefficients
      root Sparse data
      root Reactant products
      root Jacobian of reactant products
      root User-defined reaction rate laws
      root Update photolysis rate coefficients
      root Update all rate coefficients
      root Update solar intensity
      root Check mass balance for selected atoms
      root Set initial values
      root Shuffle concentration vector
      root Shuffle concentration vector
      \    
      ==== ============================================================

.. _`sec:output-map`:

============
The map file
============

The map file root contains a summary of all the functions, subroutines
and data structures defined in the code file, plus a summary of the
numbering and category of the species involved.

This file contains supplementary information for the user. Several
statistics are listed here, like the total number equations, the total
number of species, the number of variable and fixed species. Each
species from the chemical mechanism is then listed followed by its type
and numbering.

Furthermore it contains the complete list of all the functions generated
in the target source file. For each function, a brief description of the
computation performed is attached containing also the meaning of the
input and output parameters.
