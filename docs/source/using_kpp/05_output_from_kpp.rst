.. _output-from-kpp:

###############
Output from KPP
###############

This chapter describes the source code files that are generated by
KPP.

.. _f90-code:

==================
The Fortran90 Code
==================

The code generated by KPP is organized in a set of separate files. Each
has a complete description of how it was generated at the begining of
the file. The files associated with root are named with a
corresponding prefix :code:`ROOT_`  A short description of each file
is contained in the following sections.

.. figure:: ../_static/kpp2_use_diagr.png
   :align: center
   :alt: Interdependencies of the KPP-generated files.

   Interdependencies of the KPP-generated files. Each arrow starts at
   the module that exports a variable or subroutine and points to the
   module that imports it via the Fortran90 :code:`USE` instruction.
   The prefix :code:`ROOT_` has been omitted from module names for
   better readability. Dotted boxes show optional files that are only
   produced under certain circumstances.

All subroutines and functions, global parameters, variables, and
sparsity data structures  are encapsulated in modules. There is
exactly one module in each file, and the name of the module is
identical to the file name but without  the suffix :code:`.f90` or
:code:`.F90`. The figure above shows how these  modules are related to
each other. The generated code is consistent with the Fortran90
standard. It will not exceed the maximum number of 39 continuation
lines. If KPP cannot properly split an expression to keep the number
of continuation lines below the threshold then it will generate a
warning message pointing to the location of this expression.


.. important:: The default Fortran90 file suffix is :code:`.f90`.  This can be
   changed to :code:`F90` by setting :command:`#UPPERCASEF90 on` in the KPP
   definition file.

.. _Main:

ROOT_Main
---------

:file:`ROOT_Main.f90` (or :file:`ROOT_Main.F90`) root is the main
Fortran90 program. It contains the driver after modifications by the
substitution preprocessor. The name of the file is computed by KPP by
appending the suffix to the root name.

Using :command:`#DRIVER none` will skip generating this file.

.. _Model:

ROOT_Model
----------

The file :file:`ROOT_Model.f90` (or :file:`ROOT_Model.F90`) completely
defines the model by using all the associated modules.

.. _Initialize:

ROOT_Initialize
---------------

The file :file:`ROOT_Initialize.f90` (or :file:`ROOT_Initialize.F9O`)
contains the subroutine which defines initial values of the chemical
species. The driver calls the subroutine once before the time
integration loop starts.

.. _Integrator:

ROOT_Integrator
---------------

The file :file:`ROOT_Integrator.f90` (or :file:`ROOT_Integrator.F90`)
contains the subroutine which is called every time step during the
integration. The integrator that was chosen with :command:`#INTEGRATOR`
is also included in this file.  In case of an unsuccessful
integration, the module root provides a short error message
in the public variable :code:`IERR_NAME`.

.. _Monitor:

ROOT_Monitor
------------

The file :file:`ROOT_Monitor.f90` (:file:`ROOT_Monitor.F90`) contains
arrays with information about the chemical mechanism. The names of all
species are included in :code:`SPC_NAMES` and the names of all
equations are included in :code:`EQN_NAMES`.

It was shown in :ref:`eqntags` that each reaction
in the section may start with an equation tag which is enclosed in
angle brackets, e.g.:

.. code-block:: console

   <J1> NO2 + hv = NO + O : 0.533*SUN;

If the equation tags are switched on, KPP also generates the array . In
combination wiunction that converts the equation tag to the
KPP-internal eer, this can be used to describe a reaction:

.. code-block::

     PRINT *,'is:', &
       EQN_NAMJ1'))

The following bles are also declared in
:file:`ROOT_Mo:file:`ROOT_Monitor.F90`):

.. _Precision:

ROOT_Precision
--------------

Fortran90 code uses parameterized real
types. :code:`ROOT_Precision.f90` (or :code:`ROOT_Precision.F90`) contains the
following real kind definitions:

.. code-block:: F90

   ! KPP_SP - Single precision kind
     INTEGER, PARAMETER :: &
       SP = SELECTED_REAL_KIND(6,30)
   ! KPP_DP - Double precision kind
     INTEGER, PARAMETER :: &
       DP = SELECTED_REAL_KIND(12,300)

Depending on the choice of the command, the real variables are of type
double (:code:`REAL(kind=dp)`) or single precision
(:code:`REAL(kind=sp)`). Changing the parameters of the
function in this module will cause a change in the working precision
for the whole model.

.. _Rates:

ROOT_Rates
----------

The code to update the rate constants is in :code:`ROOT_Rates.f90` (or
:code:`ROOT_Rates.F90`). The user defined rate law functions are also
placed here.

.. _Parameters:

ROOT_Parameters
---------------

The global parameters listed below below are defined and
initialized in :code:`ROOT_Parameters.f90` (or
:code:`ROOT_Parameters.F90`).  The values listed in the third column
are taken from the :code:`small_strato` example mechanism, which is
described in :ref:`running-kpp-with-an-example-mechanism`.

.. table:: Parameters declared in ROOT_Parameter
   :align: center

   +--------------------+---------------------------------------------+--------+
   | Parameter          | Represents                                  | Value  |
   +====================+=============================================+========+
   | :code:`NSPEC`      | No. chemical species                        | 7      |
   +--------------------+---------------------------------------------+--------+
   | :code:`NVAR`       | No. variable species                        | 5      |
   +--------------------+---------------------------------------------+--------+
   | :code:`NFIX`       | No. fixed species                           | 2      |
   +--------------------+---------------------------------------------+--------+
   | :code:`NREACT`     | No. reactions                               | 10     |
   +--------------------+---------------------------------------------+--------+
   | :code:`NONZERO`    | No. nonzero entries Jacobian                | 18     |
   +--------------------+---------------------------------------------+--------+
   | :code:`LU_NONZERO` | As above, after LU factorization            | 19     |
   +--------------------+---------------------------------------------+--------+
   | :code:`NHESS`      | Length, sparse Hessian                      | 10     |
   +--------------------+---------------------------------------------+--------+
   | :code:`NJVRP`      | Length, sparse Jacobian JVRP                | 13     |
   +--------------------+---------------------------------------------+--------+
   | :code:`NSTOICM`    | Length, stoichiometric matrix               | 22     |
   +--------------------+---------------------------------------------+--------+
   | :code:`ind_spc`    | Index of species *spc* in :code:`C`         |        |
   +--------------------+---------------------------------------------+--------+
   | :code:`indf_spc`   | Index of fixed species *spc* in :code:`FIX` |        |
   +--------------------+---------------------------------------------+--------+

KPP orders the variable species such that the sparsity pattern of the
Jacobian is maintained after an LU decomposition. For our example there
are five variable species (=5) ordered as

.. code-block:: F90

   ind_O1D=1, ind_O=2, ind_O3=3, ind_NO=4, ind_NO2=5

and two fixed species (=2)

.. code-block:: F90

   ind_M = 6, ind_O2 = 7.

KPP defines a complete set of simulation parameters, including the
numbers of variable and fixed species, the number of chemical reactions,
the number of nonzero entries in the sparse Jacobian and in the sparse
Hessian, etc.

.. _Global:

ROOT_Global
-----------

The global variables listed below are declared in
:code:`ROOT_Global.f90` (or :code:`ROOT_Global.F90`).

.. table:: Global variables declared in ROOT_Global
   :align: center

   +-------------------------+---------------------------------------------+
   | Global variable         | Represents                                  |
   +=========================+=============================================+
   | :code:`C(NSPEC)`        | Concentrations, all species                 |
   +-------------------------+---------------------------------------------+
   | :code:`VAR(:)`          | Concentrations, variable species (pointer)  |
   +-------------------------+---------------------------------------------+
   | :code:`FIX(:)`          | Concentrations, fixed species (pointer)	   |
   +-------------------------+---------------------------------------------+
   | :code:`RCONST(NREACT)`  | Rate coefficient values			   |
   +-------------------------+---------------------------------------------+
   | :code:`TIME`            | Current integration time			   |
   +-------------------------+---------------------------------------------+
   | :code:`SUN`             | Sun intensity between 0 and 1		   |
   +-------------------------+---------------------------------------------+
   | :code:`TEMP`            | Temperature				   |
   +-------------------------+---------------------------------------------+
   | :code:`TSTART, TEND`    | Simulation start/end time		   |
   +-------------------------+---------------------------------------------+
   | :code:`DT`              | Simulation step				   |
   +-------------------------+---------------------------------------------+
   | :code:`ATOL(NSPEC)`     | Absolute tolerances			   |
   +-------------------------+---------------------------------------------+
   | :code:`RTOL(NSPEC)`     | Relative tolerances			   |
   +-------------------------+---------------------------------------------+
   | :code:`STEPMIN`         | Lower bound for time step		   |
   +-------------------------+---------------------------------------------+
   | :code:`STEPMAX`         | Upper bound for time step		   |
   +-------------------------+---------------------------------------------+
   | :code:`CFACTOR`         | Conversion factor                           |
   +-------------------------+---------------------------------------------+

Both variable and fixed species are stored in the one-dimensional
array :code:`C`. The first part (indices from code:`1` to :code:`NVAR`)
contains the variable species, and the second part (indices from to
:code:`NVAR+1` to :code:`NSPEC`) the fixed species. The total number
of species is the sum of the :code:`NVAR` and :code:`NFIX`. The parts
can also be accessed separately through pointer variables :code:`VAR` and
:code:`FIX`, which point to the proper elements in :code:`C`.

.. code-block:: F90

   VAR(1:NVAR) => C(1:NVAR)
   FIX(1:NFIX) => C(NVAR+1:NSPEC)

.. important::

   In previous versions of KPP, Fortran90 code was generated with
   :code:`VAR` and :code:`FIX` being linked to the :code:`C` array
   with an :code:`EQUIVALENCE` statement.  This construction, however,
   is not thread-safe, and it prevents KPP-generated Fortran90 code
   from being used within parallel environments (e.g. such as an
   `OpenMP <https://openmp.org>`_ parallel loop).

   We have modified KPP 2.5.0 and later versions to make KPP-generated
   Fortran90 code thread-safe.  :code:`VAR` and
   :code:`FIX` are now :code:`POINTER` variables that
   point to the proper slices of the :code:`C` array.  They are also
   nullified when no longer needed.  :code:`VAR` and :code:`FIX` are
   now also kept internal to the various integrator files located in
   the :file:`$KPP_HOME/int` folder.

.. _Function:

ROOT_Function
-------------

The chemical ODE system for our :code:`small_strato` example
(described in :ref:`running-kpp-with-an-example-mechanism`) is:

.. math::

   \begin{aligned}
   \frac{d[O(^1D)]}{dt} & = & k_{5}\, [O_3] - k_{6}\, [O(^1D)]\, [M] - k_{7}\, [O(^1D)]\, [O_3]\\
   \frac{d[O]}{dt} & = & 2\, k_{1}\, [O_2] - k_{2}\, [O]\, [O_2] + k_{3}\, [O_3]\\
   & & - k_{4}\, [O]\, [O_3]+ k_{6}\, [O(^1D)]\, [M]\\
   & & - k_{9}\, [O]\, [NO_2] + k_{10}\, [NO_2]\\
   \frac{d[O_3]}{dt} & = & k_{2}\, [O]\, [O_2] - k_{3}\,
   [O_3] - k_{4}\, [O]\, [O_3] - k_{5}\, [O_3]\\
   & & - k_{7}\, [O(^1D)]\, [O_3] - k_{8}\, [O_3]\, [NO]\\
   \frac{d[NO]}{dt} & = & - k_{8}\, [O_3]\, [NO] + k_{9}\, [O]\, [NO_2] + k_{10}\, [NO_2]\\
   \frac{d[NO_2]}{dt} & = & k_{8}\, [O_3]\, [NO] - k_{9}\, [O]\, [NO_2] - k_{10}\, [NO_2]\\
   \end{aligned}

where square brackets denote concentrations of the species. The code for
the ODE function is in root. The chemical reaction mechanism represents
a set of ordinary differential equations (ODEs) of dimension . The
concentrations of fixed species are parameters in the derivative
function. The subroutine computes first the vector of reaction rates and
then the vector of variable species time derivatives. The input
arguments , , and are the concentrations of variable species, fixed
species, and the rate coefficients, respectively. Below is the Fortran90
code generated by KPP for the ODE function of our example.

.. code-block:: F90

   SUBROUTINE Fun (V, F, RCT, Vdot, Aout, Vdotout )

   ! V - Concentrations of variable species (local)
     REAL(kind=dp) :: V(NVAR)
   ! F - Concentrations of fixed species (local)
     REAL(kind=dp) :: F(NVAR)
   ! RCT - Rate constants (local)
     REAL(kind=dp) :: RCT(NREACT)
   ! Vdot - Time derivative of variable species concentrations
     REAL(kind=dp) :: Vdot(NVAR)
   ! Aout - Optional argument to return equation rate constants
     REAL(kind=dp), OPTIONAL :: Aout(NREACT)
   ! Vdotout - Optional argument to return time derivative of variable species
     REAL(kind=dp), OPTIONAL :: Vdotout(NVAR)


   ! Computation of equation rates
     A(1) = RCT(1)*F(2)
     A(2) = RCT(2)*V(2)*F(2)
     A(3) = RCT(3)*V(3)
     A(4) = RCT(4)*V(2)*V(3)
     A(5) = RCT(5)*V(3)
     A(6) = RCT(6)*V(1)*F(1)
     A(7) = RCT(7)*V(1)*V(3)
     A(8) = RCT(8)*V(3)*V(4)
     A(9) = RCT(9)*V(2)*V(5)
     A(10) = RCT(10)*V(5)

     !### Use Aout to return equation rates
     IF ( PRESENT( Aout ) ) Aout = A

   ! Aggregate function
     Vdot(1) = A(5)-A(6)-A(7)
     Vdot(2) = 2*A(1)-A(2)+A(3) &
               -A(4)+A(6)-A(9)+A(10)
     Vdot(3) = A(2)-A(3)-A(4)-A(5) &
               -A(7)-A(8)
     Vdot(4) = -A(8)+A(9)+A(10)
     Vdot(5) = A(8)-A(9)-A(10)

     !### Use Vdotout to return time deriv. of variable species
     IF ( PRESENT( Vdotout ) ) Vdotout = V

   END SUBROUTINE Fun

.. _Jacobian:

ROOT_Jacobian and ROOT_JacobianSP
---------------------------------

The Jacobian matrix for our example contains 18 non-zero elements:

.. math::

   \begin{aligned}
     \mathbf{J}(1,1) & = & - k_{6}\, [{M}] - k_{7}\, [{O_3}]\\
     \mathbf{J}(1,3) & = & k_{5} - k_{7}\, [{O(^1D)}]\\
     \mathbf{J}(2,1) & = & k_{6}\, [{M}]\\
     \mathbf{J}(2,2) & = & - k_{2}\, [{O_2}] - k_{4}\, [{O_3}]
                           - k_{9}\, [{NO_2}]\\
     \mathbf{J}(2,3) & = & k_{3} - k_{4}\, [{O}]\\
     \mathbf{J}(2,5) & = & - k_{9}\, [{O}] + k_{10}\\
     \mathbf{J}(3,1) & = & - k_{7}\, [{O_3}]\\
     \mathbf{J}(3,2) & = & k_{2}\, [{O_2}] - k_{4}\, [{O_3}]\\
     \mathbf{J}(3,3) & = & - k_{3} - k_{4}\, [{O}] - k_{5} - k_{7}\,
                           [{O(^1D)}] - k_{8}\, [{NO}]\\
     \mathbf{J}(3,4) & = & - k_{8}\, [{O_3}]\\
     \mathbf{J}(4,2) & = & k_{9}\, [{NO_2}]\\
     \mathbf{J}(4,3) & = & - k_{8}\, [{NO}]\\
     \mathbf{J}(4,4) & = & - k_{8}\, [{O_3}]\\
     \mathbf{J}(4,5) & = & k_{9}\, [{O}] + k_{10}\\
     \mathbf{J}(5,2) & = & - k_{9}\, [{NO_2}]\\
     \mathbf{J}(5,3) & = & k_{8}\, [{NO}]\\
     \mathbf{J}(5,4) & = & k_{8}\, [{O_3}]\\
     \mathbf{J}(5,5) & = & - k_{9}\, [{O}] - k_{10}\\
   \end{aligned}

It defines how the temporal change of each chemical species depends on
all other species. For example, :math:`\mathbf{J}(5,2)` shows that :math:`NO_2`
(species number 5) is affected by :math:`O` (species number 2) via
reaction number R9. The sparse data structures for the Jacobian are
declared and initialized in :code:`ROOT_JacobianSP.f90` (or
:code:`ROOT_JacobianSP.F90`). The code for the ODE Jacobian and
sparse multiplications is in :code:`ROOT_Jacobian.f90` (or
:code:`ROOT_Jacobian.F90`). The Jacobian of the ODE function is
automatically constructed by KPP. KPP generates the Jacobian subroutine
:code:`Jac` or :code:`JacSP`  where the latter is generated when the
sparse format is required. Using the variable species :code:`V`, the fixed
species :code:`F`, and the rate coefficients :code:`RCT` as input, the
subroutine calculates the Jacobian :code:`JVS`. The default data
structures for the sparse compressed on rows Jacobian
representation are shown in the table below (for the case
where the LU fill-in is accounted for).

.. table:: Sparse Jacobian Data Structures
   :align: center

   +------------------------------+-------------------------------------+
   | Global variable              | Represents                          |
   +==============================+=====================================+
   | :code:`JVS(LU_NONZERO)`      | Jacobian nonzero elements           |
   +------------------------------+-------------------------------------+
   | :code:`LU_IROW(LU_NONZERO)`  | Row indices                         |
   +------------------------------+-------------------------------------+
   | :code:`LU_ICOL(LU_NONZERO)`  | Column indices                      |
   +------------------------------+-------------------------------------+
   | :code:`LU_CROW(NVAR+1)`      | Start of rows                       |
   +------------------------------+-------------------------------------+
   | :code:`LU_DIAG(NVAR+1)`      | Diagonal entries                    |
   +------------------------------+-------------------------------------+

stores the elements of the
Jacobian in row order. Each row starts at position , and . The location
of the -th diagonal element is . The sparse element is the Jacobian
entry in row and column . For the example KPP generates the following
Jacobian sparse data structure:

.. code-block:: F90

   LU_ICOL = (/ 1,3,1,2,3,5,1,2,3,4, &
               5,2,3,4,5,2,3,4,5 /)
   LU_IROW = (/ 1,1,2,2,2,2,3,3,3,3, &
               3,4,4,4,4,5,5,5,5 /)
   LU_CROW = (/ 1,3,7,12,16,20 /)
   LU_DIAG = (/ 1,4,9,14,19,20 /)

This is visualized the figure below.  The sparsity coordinate
vectors are computed by KPP and initialized statically. These vectors
are constant as the sparsity pattern of the Jacobian does not change
during the computation.

.. figure:: ../_static/small_jac.png
   :alt: The sparsity pattern of the Jacobian for the small_strato example.
   :scale: 60%
   :align: center

   The sparsity pattern of the Jacobian for the :code:`small_strato`
   example. All non-zero elements are marked with a bullet. Note that
   even though  :math:`\mathbf{J}(3,5)` is zero, it is also included here
   because of the fill-in.

Two other KPP-generated routines, :code:`Jac_SP_Vec` and
:code:`JacTR_SP_Vec`, are useful for direct and adjoint
sensitivity analysis. They perform sparse multiplication of
:code:`JVS` (or its transpose for :code:`JacTR_SP_Vec`) with the
user-supplied vector without any indirect addressing.

.. _Hessian:

ROOT_Hessian and ROOT_HessianSP
--------------------------------

The sparse data structures for the Hessian are declared and initialized
in :code:`ROOT_Hessian.f90` (or :code:`ROOT_Hessian.F90`). The Hessian
function and associated sparse multiplications are in
:code:`ROOT_Hessian.f90` (or :code:`ROOT_Hessian.F90`). The Hessian
contains the second order derivatives of the time derivative
functions. More exactly, the Hessian is a 3-tensor such that

.. math::

   H_{i,j,k} = \frac{\partial^2 ({\mathrm{d}}c/{\mathrm{d}}t)_i}{\partial c_j \,\partial c_k}~,
     \qquad 1 \le i,j,k \le N_{\rm var}~.
   \label{eqn:Hessian1}

KPP generates the routine :code:`Hessian`. Using the variable species
:code:`V`, the fixed species :code:`F`, and the rate coefficients
:code:`RCT` as input, the subroutine calculates the Hessian. The
Hessian is a very sparse tensor. The sparsity of the Hessian for our
example is visualized in the figure below:

   .. figure:: ../_static/small_hess1.png
      :alt: The Hessian of the small_strato example
      :align: center

      The Hessian of the small_strato example.

KPP computes the number of nonzero Hessian entries and saves it in the
variable :code:`NHESS`. The Hessian itself is represented in
coordinate sparse format. The real vector :code:`HESS` holds the values, and the
integer vectors :code:`IHESS_I`, :code:`IHESS_J`, and :code:`IHESS_K`
hold the indices of nonzero entries as illustrated in the table below.

.. table:: Sparse Hessian Data
   :align: center

   +-------------------------+----------------------------------------------+
   | Variable                | Represents                                   |
   +=========================+==============================================+
   | :code:`HESS(NHESS)`     | Hessian nonzero elements :math:`_{i,j,k}`    |
   +-------------------------+----------------------------------------------+
   | :code:`IHESS_I(NHESS)`  | Index :math:`i` of element :math:`_{i,j,k}`  |
   +-------------------------+----------------------------------------------+
   | :code:`IHESS_J(NHESS)`  | Index :math:`j` of element :math:`_{i,j,k}`  |
   +-------------------------+----------------------------------------------+
   | :code:`IHESS_J(NHESS)`  | Index :math:`k` of element :math:`_{i,j,k}`  |
   +-------------------------+----------------------------------------------+

Since the time
derivative function is smooth, these Hessian matrices are symmetric,
:math:`_{i,j,k}`\ =\ :math:`_{i,k,j}`. KPP stores only those entries
:math:`_{i,j,k}` with :math:`j \le k`. The sparsity coordinate vectors ,
, and are computed by KPP and initialized statically. They are constant
as the sparsity pattern of the Hessian does not change during the
computation.


The routines and compute the action of the Hessian (or its transpose) on
a pair of user-supplied vectors and . Sparse operations are employed to
produce the result vector.

.. _LinearAlgebra:

root\ ``_LinearAlgebra.f90``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sparse linear algebra routines are in the file root. To numerically
solve for the chemical concentrations one must employ an implicit
timestepping technique, as the system is usually stiff. Implicit
integrators solve systems of the form

.. math:: P\, x = (I - h \gamma J)\, x = b

where the matrix :math:`P=I - h \gamma J` is refered to as the
“prediction matrix”. :math:`I` the identity matrix, :math:`h` the
integration time step, :math:`\gamma` a scalar parameter depending on
the method, and :math:`J` the system Jacobian. The vector :math:`b` is
the system right hand side and the solution :math:`x` typically
represents an increment to update the solution.

The chemical Jacobians are typically sparse, i.e. only a relatively
small number of entries are nonzero. The sparsity structure of :math:`P`
is given by the sparsity structure of the Jacobian, and is produced by
KPP (with account for the fill-in) as discussed above.

KPP generates the sparse linear algebra subroutine which performs an
in-place, non-pivoting, sparse LU decomposition of the prediction matrix
:math:`P`. Since the sparsity structure accounts for fill-in, all
elements of the full LU decomposition are actually stored. The output
argument returns a value that is nonzero if singularity is detected.

The subroutines and use the in-place LU factorization :math:`P` as
computed by and perform sparse backward and forward substitutions (using
:math:`P` or its transpose). The sparse linear algebra routines and are
extremely efficient, as shown by :raw-latex:`\citep{IMPLEMENTATION}`.

.. _Stoichiom-and_StoichiomSP:

root_Stoichiom.f90 and root_StoichiomSP.f90 (or .F90)
-----------------------------------------------------

These files contain a description of the chemical mechanism in
stoichiometric form. The file root contains the functions for reactant
products and its Jacobian, and derivatives with respect to rate
coefficients. The declaration and initialization of the stoichiometric
matrix and the associated sparse data structures is done in root.

The stoichiometric matrix is constant sparse. For our example the matrix
has 22 nonzero entries out of 50 entries. KPP produces the
stoichiometric matrix in sparse, column-compressed format, as shown in
Table `7 <#tab:sparse-stoicm>`__. Elements are stored in columnwise
order in the one-dimensional vector of values . Their row and column
indices are stored in and respectively. The vector contains pointers to
the start of each column. For example column starts in the sparse vector
at position and ends at . The last value simplifies the handling of
sparse data structures.

.. container::
   :name: tab:sparse-stoicm

   .. table:: Sparse Stoichiometric Matrix

      =============== =====================
      Global variable Represents
      \               Stoichiometric matrix
      \               Row indices
      \               Column indices
      \               Start of columns
      \
      =============== =====================

The subroutine computes the reactant products for each reaction, and the
subroutine computes the Jacobian of reactant products vector, i.e.:

.. math:: {\tt JVRP} = \partial {\tt ARP} / \partial {\tt V}

The matrix is sparse and is computed and stored in row compressed sparse
format, as shown in Table `8 <#tab:sparse-jvrp>`__. The parameter holds
the number of nonzero elements. For our example:

::

   NJVRP = 13
   CROW_JVRP = (/ 1,1,2,3,5,6,7,9,11,13,14 /)
   ICOL_JVRP = (/ 2,3,2,3,3,1,1,3,3,4,2,5,4 /)

.. container::
   :name: tab:sparse-jvrp

   .. table:: Sparse Data for Jacobian of Reactant Products

      =============== ========================
      Global variable Represents
      \               Nonzero elements of JVRP
      \               Column indices in JVRP
      \               Row indices in JVRP
      \               Start of rows in JVRP
      \
      =============== ========================

If is set to , the stoichiometric formulation allows a direct
computation of the derivatives with respect to rate coefficients.

The subroutine computes the partial derivative of the ODE function with
respect to a subset of reaction coefficients, whose indices are
specifies in the array

.. math:: {\tt DFDR} = \partial {\tt Vdot} / \partial {\tt RCT(JCOEFF)}

Similarly one can obtain the partial derivative of the Jacobian with
respect to a subset of the rate coefficients. More exactly, KPP
generates the subroutine which calculates , the product of this partial
derivative with a user-supplied vector:

.. math:: {\tt DJDR} = [ \partial {\tt JVS} / \partial {\tt RCT(JCOEFF)} ] \times {\tt U}

.. _Stochastic:

root_Stochastic.f90 (or .F90)
-----------------------------

If the generation of stochastic functions is switched on, KPP produces
the file root with the following functions:

calculates the propensity vector. The propensity function uses the
number of molecules of variable () and fixed () species, as well as the
stochastic rate coefficients () to calculate the vector of propensity
rates (). The propensity :math:`_j` defines the probability that the
next reaction in the system is the :math:`j^{th}` reaction.

converts deterministic rates to stochastic. The stochastic rate
coefficients () are obtained through a scaling of the deterministic rate
coefficients (). The scaling depends on the of the reaction container
and on the number of molecules which react.

calculates changes in the number of molecules. When the reaction with
index takes place, the number of molecules of species involved in that
reaction changes. The total number of molecules is updated by the
function.

These functions are used by the Gillespie numerical integrators (direct
stochastic simulation algorithm). These integrators are provided in both
Fortran90 and C implementations (the template file name is ). Drivers
for stochastic simulations are also implemented (the template file name
is ).

.. _Util:

root_Util.f90 (or .F90)
-----------------------

The utility and input/output functions are in root. In addition to the
chemical system description routines discussed above, KPP generates
several utility routines, some of which are summarized in
Table `[tab:functions] <#tab:functions>`__.

The subroutines , , and can be used to print the concentration of the
species that were selected with to the file root.

.. _Mex-code:

root_mex_Fun.f90, root_mex_Jac_SP.f90, and root_mex_Hessian.f90 (or .F90)
-------------------------------------------------------------------------

Mex is a *M*\ atlab *ex*\ tension. KPP generates the mex routines for
the ODE function, Jacobian, and Hessian, for the target languages C,
Fortran77, and Fortran90. After compilation (using Matlab’s mex
compiler) the mex functions can be called instead of the corresponding
Matlab m-functions. Since the calling syntaxes are identical, the user
only has to insert the string within the corresponding function name.
Replacing m-functions by mex-functions gives the same numerical results,
but the computational time could be considerably smaller, especially for
large kinetic systems.

If possible we recommend to build mex files using the C language, as
Matlab offers most mex interface options for the C language. Moreover,
Matlab distributions come with a native C compiler (lcc) for building
executable functions from mex files. Fortran77 mex files work well on
most platforms without additional efforts. However, the mex files built
using Fortran90 may require further platform-specific tuning of the mex
compiler options.

.. _Makefile:

============
The Makefile
============


KPP produces a Makefile that allows for an easy compilation of all
KPP-generated source files. The file name is . The Makefile assumes that
the selected driver contains the main program. However, if no driver was
selected (i.e. ), it is necessary to add the name of the main program
file manually to the Makefile.

.. _C-code:

==========
The C Code
==========

The driver file root contains the main (driver) and numerical integrator
functions, as well as declarations and initializations of global
variables. The generated C code includes three header files which are -d
in other files as appropriate. The global parameters
(Table `3 <#tab:parameters>`__) are -d in the header file root. The
global variables (Table `4 <#tab:global>`__) are extern-declared in
root, and declared in the driver file root. The header file root
contains extern declarations of sparse data structures for the Jacobian
(Table `5 <#tab:sparse-jac>`__), Hessian
(Table `6 <#tab:sparse-hess>`__), stoichiometric matrix
(Table `7 <#tab:sparse-stoicm>`__), and the Jacobian of reaction
products (Table `8 <#tab:sparse-jvrp>`__). The actual declarations of
each data structures is done in the corresponding files.

The code for the ODE function (Sect. `4.1.10 <#sec:output-ode-fun>`__)
is in root. The code for the ODE Jacobian and sparse multiplications
(Sect. `4.1.11 <#sec:output-ode-jac>`__) is in root, and the declaration
and initialization of the Jacobian sparse data structures
(Table `5 <#tab:sparse-jac>`__) is in the file root. Similarly, the
Hessian function and associated sparse multiplications
(Section `4.1.12 <#sec:output-ode-hess>`__) are in root, and the
declaration and initialization of Hessian sparse data structures (Table
`6 <#tab:sparse-hess>`__) in root.

The file root contains the functions for reactant products and its
Jacobian, and derivatives with respect to rate coefficients
(Sect. `4.1.14 <#sec:output-stoichiom>`__). The declaration and
initialization of the stoichiometric matrix and the associated sparse
data structures (Tables `7 <#tab:sparse-stoicm>`__ and
`8 <#tab:sparse-jvrp>`__) is done in root.

Sparse linear algebra routines (Sect. `4.1.13 <#sec:output-la>`__) are
in the file root. The code to update the rate constants and user defined
code for rate laws is in root.

Various utility and input/output functions
(Sect. `4.1.16 <#sec:output-utility>`__) are in root and root.

Finally, mex gateway routines that allow the C implementation of the ODE
function, Jacobian, and Hessian to be called directly from Matlab
(Sect. `4.1.17 <#sec:output-mexcode>`__) are also generated (in the
files root, root, and root).

.. _f77-code:

==================
The Fortran77 Code
==================

The general layout of the Fortran77 code is similar to the layout of the
C code. The driver file root contains the main (driver) and numerical
integrator functions.

The generated Fortran77 code includes three header files. The global
parameters (Table `3 <#tab:parameters>`__) are defined as parameters and
initialized in the header file root. The global variables
(Table `4 <#tab:global>`__) are declared in root as common block
variables. There are global common blocks for real (), integer (), and
character () global data. They can be accessed from within each program
unit that includes the global header file.

The header file root contains common block declarations of sparse data
structures for the Jacobian (Table `5 <#tab:sparse-jac>`__), Hessian
(Table `6 <#tab:sparse-hess>`__), stoichiometric matrix
(Table `7 <#tab:sparse-stoicm>`__), and the Jacobian of reaction
products (Table `8 <#tab:sparse-jvrp>`__). These sparse data structures
are initialized in four named block data statements: (in root), (in
root), and (in root).

The code for the ODE function (Sect. `4.1.10 <#sec:output-ode-fun>`__)
is in root. The code for the ODE Jacobian and sparse multiplications
(Sect. `4.1.11 <#sec:output-ode-jac>`__) is in root. The Hessian
function and associated sparse multiplications
(Sect. `4.1.12 <#sec:output-ode-hess>`__) are in root.

The file root contains the functions for reactant products and its
Jacobian, and derivatives with respect to rate coefficients
(Sect. `4.1.14 <#sec:output-stoichiom>`__). The declaration and
initialization of the stoichiometric matrix and the associated sparse
data structures (Tables `7 <#tab:sparse-stoicm>`__ and
`8 <#tab:sparse-jvrp>`__) is done in the block data statement.

Sparse linear algebra routines (Sect. `4.1.13 <#sec:output-la>`__) are
in the file root. The code to update the rate constants is in root, and
the utility and input/output functions
(Sect. `4.1.16 <#sec:output-utility>`__) are in root and root.

Matlab-mex gateway routines for the ODE function, Jacobian, and Hessian
are discussed in Sect. `4.1.17 <#sec:output-mexcode>`__.

.. _matlab-code:

===============
The Matlab Code
===============

Matlab (http://www.mathworks.com/products/matlab/) provides a high-level
programming environment that allows algorithm development, numerical
computations, and data analysis and visualization. The KPP-generated
Matlab code allows for a rapid prototyping of chemical kinetic schemes,
and for a convenient analysis and visualization of the results.
Differences between different kinetic mechanisms can be easily
understood. The Matlab code can be used to derive reference numerical
solutions, which are then compared against the results obtained with
user-supplied numerical techniques. Last but not least Matlab is an
excellent environment for educational purposes. KPP/Matlab can be used
to teach students fundamentals of chemical kinetics and chemical
numerical simulations.

Each Matlab function has to reside in a separate m-file. Function calls
use the m-function-file names to reference the function. Consequently,
KPP generates one m-function-file for each of the functions discussed in
Sections `4.1.10 <#sec:output-ode-fun>`__,
`4.1.11 <#sec:output-ode-jac>`__, `4.1.12 <#sec:output-ode-hess>`__,
`4.1.13 <#sec:output-la>`__, `4.1.14 <#sec:output-stoichiom>`__, and
`4.1.16 <#sec:output-utility>`__. The names of the m-function-files are
the same as the names of the functions (prefixed by the model name
root).

The Matlab syntax for calling each function is

.. code-block:: matlab

   [Vdot] = Fun    (V, F, RCT);
   [JVS ] = Jac_SP (V, F, RCT);
   [HESS] = Hessian(V, F, RCT);

The global parameters (Table `3 <#tab:parameters>`__) are defined as
Matlab variables and initialized in the file root. The variables of
Table `4 <#tab:global>`__ are declared as Matlab variables in the file
root. They can be accessed from within each Matlab function by using
declarations of the variables of interest.

The sparse data structures for the Jacobian
(Table `5 <#tab:sparse-jac>`__), the Hessian
(Table `6 <#tab:sparse-hess>`__), the stoichiometric matrix
(Table `7 <#tab:sparse-stoicm>`__), and the Jacobian of reaction
products (Table `8 <#tab:sparse-jvrp>`__) are declared as Matlab
variables in the file root. They are initialized in separate m-files,
namely root root, and root respectively.

Two wrappers (root and root) are provided for interfacing the ODE
function and the sparse ODE Jacobian with Matlab’s suite of ODE
integrators. Specifically, the syntax of the wrapper calls matches the
syntax required by Matlab’s integrators like ode15s. Moreover, the
Jacobian wrapper converts the sparse KPP format into a Matlab sparse
matrix.

.. container:: table*

   .. container:: center

      ==== ============================================================
      File Description
      root driver
      root Global parameters
      root Global variables
      root Global monitor variables
      root Global sparsity data
      root Template for ODE function
      root ODE function
      root Template for ODE Jacobian
      root ODE Jacobian in sparse format
      root Sparsity data structures
      root ODE Hessian in sparse format
      root Sparsity data structures
      root Hessian action on vectors
      root Transposed Hessian action on vectors
      root Derivatives of Fun and Jac with respect to rate coefficients
      root Sparse data
      root Reactant products
      root Jacobian of reactant products
      root User-defined reaction rate laws
      root Update photolysis rate coefficients
      root Update all rate coefficients
      root Update solar intensity
      root Check mass balance for selected atoms
      root Set initial values
      root Shuffle concentration vector
      root Shuffle concentration vector
      \
      ==== ============================================================

.. _Map:

============
The map file
============

The map file root contains a summary of all the functions, subroutines
and data structures defined in the code file, plus a summary of the
numbering and category of the species involved.

This file contains supplementary information for the user. Several
statistics are listed here, like the total number equations, the total
number of species, the number of variable and fixed species. Each
species from the chemical mechanism is then listed followed by its type
and numbering.

Furthermore it contains the complete list of all the functions generated
in the target source file. For each function, a brief description of the
computation performed is attached containing also the meaning of the
input and output parameters.
